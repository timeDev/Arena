define(['vendor/signals'], function (signals) {
    "use strict";
    var gamepad, pointerLockElmt, handlers,
        keybinds = {},
        registry = { key: {}, mouse: {} },
        pointerLocked = false,
        prevent = false,
        mousepos = [0, 0, 0, 0],
        // Functions
        updateMouseMoveHandler, exitPointerLock, lockChangeCb, lockErrorCb, updateGamepad,
        trylockpointer, bind, unbind, unbindKey, check, resetDelta,
        // Signals
        escape = new signals.Signal(),
        pointerlocked = new signals.Signal(),
        pointerunlocked = new signals.Signal();

    handlers = {
        keydown: function (e) {
            if (prevent) { e.preventDefault(); }
            var which = e.which || e.charCode || e.keyCode;
            if (e === 27) {
                escape.dispatch();
            }
            registry.key[which] = 1.0;
        },
        keyup: function (e) {
            if (prevent) { e.preventDefault(); }
            var which = e.which || e.charCode || e.keyCode;
            registry.key[which] = 0.0;
        },
        mousedown: function (e) {
            if (prevent) { e.preventDefault(); }
            var which = (e.button & 1 ? 1 : (e.button & 2 ? 3 : (e.button & 4 ? 2 : 0)));
            registry.mouse[which] = 1.0;
        },
        mouseup: function (e) {
            if (prevent) { e.preventDefault(); }
            var which = (e.button & 1 ? 1 : (e.button & 2 ? 3 : (e.button & 4 ? 2 : 0)));
            registry.mouse[which] = 0.0;
        },
        mousemove1: function (e) {
            var prevX = mousepos[0], prevY = mousepos[1],
                deltaX = e.movementX || e.webkitMovementX || e.mozMovementX || prevX - e.pageX,
                deltaY = e.movementY || e.webkitMovementY || e.mozMovementY || prevY - e.pageY;
            mousepos = [e.pageX, e.pageY, mousepos[2] + deltaX, mousepos[3] + deltaY];
        },
        mousemove2: function (e) {
            var deltaX = e.movementX || e.webkitMovementX || e.mozMovementX || 0,
                deltaY = e.movementY || e.webkitMovementY || e.mozMovementY || 0;
            mousepos = [mousepos[0] + deltaX, mousepos[1] + deltaY, mousepos[2] + deltaX, mousepos[3] + deltaY];
        }
    };
    handlers.mousemove = handlers.mousemove1;

    updateMouseMoveHandler = function () {
        document.removeEventListener("mousemove", handlers.mousemove, false);
        handlers.mousemove = pointerLocked ? handlers.mousemove2 : handlers.mousemove1;
        document.addEventListener("mousemove", handlers.mousemove, false);
    };

    lockChangeCb = function () {
        if (document.pointerLockElement === pointerLockElmt || document.mozPointerLockElement === pointerLockElmt || document.webkitPointerLockElement === pointerLockElmt) {
            pointerLocked = true;
            pointerlocked.dispatch();
        } else {
            pointerLocked = false;
            pointerunlocked.dispatch();
        }
        updateMouseMoveHandler();
    };

    lockErrorCb = function () {
        window.console.error('Error requesting pointer lock! Please report this issue.');
    };

    window.addEventListener('keydown', handlers.keydown, false);
    window.addEventListener('keyup', handlers.keyup, false);
    window.addEventListener('mousedown', handlers.mousedown, false);
    window.addEventListener('mouseup', handlers.mouseup, false);

    document.addEventListener("mousemove", handlers.mousemove, false);

    document.addEventListener('pointerlockchange', lockChangeCb, false);
    document.addEventListener('mozpointerlockchange', lockChangeCb, false);
    document.addEventListener('webkitpointerlockchange', lockChangeCb, false);

    document.addEventListener('pointerlockerror', lockErrorCb, false);
    document.addEventListener('mozpointerlockerror', lockErrorCb, false);
    document.addEventListener('webkitpointerlockerror', lockErrorCb, false);

    // TODO: Proper polyfill
    navigator.getGamepads = navigator.getGamepads || navigator.webkitGetGamepads || function () { return []; };

    updateGamepad = function () {
        var pads = navigator.getGamepads(), pad;
        if (!pads || pads.length === 0 || !pads[0]) { return; }

        pad = pads[0];
        if (pad.mapping === "standard") {
            gamepad = pad;
        } else {
            window.console.log("Non standard gamepad detected: " + pad.id);
        }
    };

    trylockpointer = function (element) {
        if (pointerLocked) { return; }
        element.requestPointerLock = element.requestPointerLock || element.webkitRequestPointerLock || element.mozRequestPointerLock;
        exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock || document.mozExitPointerLock;
        if (!element.requestPointerLock) { return false; }
        pointerLockElmt = element;
        element.requestPointerLock();
        return true;
    };

    bind = function (what, key, name) {
        keybinds[name] = { what: what, key: key };

        // Init keys so that they don't have to be pressed once
        if (what === "key" || what === "mouse") {
            registry[what][key] = 0.0;
        }
    };

    unbind = function (name) {
        delete keybinds[name];
    };

    unbindKey = function (what, key) {
        var bindings = keybinds, prop;
        for (prop in bindings) {
            if (bindings.hasOwnProperty(prop) && bindings[prop].what === what && bindings[prop].key === key) {
                bindings[prop] = null;
            }
        }
    };

    check = function (name) {
        var binding = keybinds[name], what = binding.what, key = binding.key;
        if (what === "key" || what === "mouse") {
            return registry[what][key];
        }
        if (what === "padkey") {
            return gamepad && gamepad.buttons[key].value;
        }
        if (what === "padaxis") {
            return gamepad && gamepad.axes[key];
        }
        if (what === "mouseaxis") {
            return mousepos[key];
        }
    };

    resetDelta = function () {
        mousepos[2] = 0.0;
        mousepos[3] = 0.0;
    };

    return {
        /// <summary>Exits the pointer lock and returns full control to the user.</summary>
        exitPointerLock: exitPointerLock,
        /// <summary>Updates gamepad state.</summary>
        updateGamepad: updateGamepad,
        /// <summary>Attempts to aquire a pointer lock.</summary>
        /// <returns type="Boolean">true, if successful, false if API is not available,
        /// undefined if pointer is already locked.</returns>
        trylockpointer: trylockpointer,
        /// <summary>Creates a new keybinding.</summary>
        bind: bind,
        /// <summary>Deletes a keybinding by name.</summary>
        unbind: unbind,
        /// <summary>Deletes a keybinding by key.</summary>
        unbindKey: unbindKey,
        /// <summary>Checks the state of a keybinding.</summary>
        check: check,
        /// <summary>Resets mouse-delta values.</summary>
        resetDelta: resetDelta,
        
        /// <field name="escape" type="signals.Signal">Dispatched, when the escape button is pressed.</field>
        escape: escape,
        /// <field name="pointerlocked" type="signals.Signal">Dispatched, when a pointer lock is aquired.</field>
        pointerlocked: pointerlocked,
        /// <field name="pointerunlocked" type="signals.Signal">Dispatched, when a pointer lock is lost.</field>
        pointerunlocked: pointerunlocked
    };
});